AWSTemplateFormatVersion: '2010-09-09'
Description: API Gateway configuration for AI Scribe

Parameters:
  Stage:
    Type: String
    Description: Deployment stage
  
  UserPoolArn:
    Type: String
    Description: Cognito User Pool ARN for authentication
  
  DomainName:
    Type: String
    Default: ""
    Description: Custom domain name (optional)

Conditions:
  HasDomainName: !Not [!Equals [!Ref DomainName, ""]]

Resources:
  # REST API
  RestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub 'ai-scribe-${Stage}'
      Description: AI Scribe REST API
      EndpointConfiguration:
        Types:
          - REGIONAL
      BinaryMediaTypes:
        - 'audio/*'
        - 'multipart/form-data'

  # API Gateway Authorizer
  ApiAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    Properties:
      Name: CognitoAuthorizer
      Type: COGNITO_USER_POOLS
      IdentitySource: method.request.header.Authorization
      RestApiId: !Ref RestApi
      ProviderARNs:
        - !Ref UserPoolArn

  # Request Validator
  RequestValidator:
    Type: AWS::ApiGateway::RequestValidator
    Properties:
      Name: RequestValidator
      RestApiId: !Ref RestApi
      ValidateRequestBody: true
      ValidateRequestParameters: true

  # API Deployment
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - HealthCheckMethod
    Properties:
      RestApiId: !Ref RestApi
      StageName: !Ref Stage
      StageDescription:
        ThrottlingBurstLimit: 1000
        ThrottlingRateLimit: 500
        LoggingLevel: INFO
        DataTraceEnabled: true
        MetricsEnabled: true
        TracingEnabled: true

  # API Stage
  ApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      StageName: !Ref Stage
      RestApiId: !Ref RestApi
      DeploymentId: !Ref ApiDeployment
      MethodSettings:
        - ResourcePath: '/*'
          HttpMethod: '*'
          LoggingLevel: INFO
          DataTraceEnabled: true
          MetricsEnabled: true
          ThrottlingBurstLimit: 1000
          ThrottlingRateLimit: 500
      AccessLogSetting:
        DestinationArn: !GetAtt ApiLogGroup.Arn
        Format: '{"requestId":"$context.requestId","ip":"$context.identity.sourceIp","caller":"$context.identity.caller","user":"$context.identity.user","requestTime":"$context.requestTime","httpMethod":"$context.httpMethod","resourcePath":"$context.resourcePath","status":"$context.status","protocol":"$context.protocol","responseLength":"$context.responseLength"}'
      Variables:
        stage: !Ref Stage

  # WebSocket API for real-time audio streaming
  WebSocketApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub 'ai-scribe-ws-${Stage}'
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: '$request.body.action'

  # WebSocket Authorizer
  WebSocketAuthorizer:
    Type: AWS::ApiGatewayV2::Authorizer
    Properties:
      Name: WebSocketCognitoAuthorizer
      ApiId: !Ref WebSocketApi
      AuthorizerType: REQUEST
      AuthorizerUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AuthorizerFunction.Arn}/invocations'
      IdentitySource:
        - 'route.request.querystring.token'

  # WebSocket Stage
  WebSocketStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      StageName: !Ref Stage
      ApiId: !Ref WebSocketApi
      AutoDeploy: true
      DefaultRouteSettings:
        ThrottlingBurstLimit: 1000
        ThrottlingRateLimit: 500
        LoggingLevel: INFO
        DataTraceEnabled: true
      AccessLogSettings:
        DestinationArn: !GetAtt WebSocketLogGroup.Arn
        Format: '{"requestId":"$context.requestId","ip":"$context.identity.sourceIp","requestTime":"$context.requestTime","routeKey":"$context.routeKey","status":"$context.status","responseLength":"$context.responseLength"}'

  # WebSocket Routes
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: '$connect'
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref WebSocketAuthorizer
      OperationName: ConnectRoute
      Target: !Sub 'integrations/${ConnectIntegration}'

  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: '$disconnect'
      AuthorizationType: NONE
      OperationName: DisconnectRoute
      Target: !Sub 'integrations/${DisconnectIntegration}'

  DefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: '$default'
      AuthorizationType: NONE
      OperationName: DefaultRoute
      Target: !Sub 'integrations/${DefaultIntegration}'

  # Placeholder integrations (will be replaced with actual Lambda functions)
  ConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PlaceholderFunction.Arn}/invocations'

  DisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PlaceholderFunction.Arn}/invocations'

  DefaultIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PlaceholderFunction.Arn}/invocations'

  # Health Check endpoint
  HealthCheckResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !GetAtt RestApi.RootResourceId
      PathPart: health

  HealthCheckMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref HealthCheckResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: '{"status":"healthy","timestamp":"$context.requestTime"}'
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: Empty

  # API Usage Plan
  ApiUsagePlan:
    Type: AWS::ApiGateway::UsagePlan
    Properties:
      UsagePlanName: !Sub 'ai-scribe-${Stage}-plan'
      Description: Usage plan for AI Scribe API
      ApiStages:
        - ApiId: !Ref RestApi
          Stage: !Ref Stage
      Throttle:
        BurstLimit: 2000
        RateLimit: 1000
      Quota:
        Limit: 1000000
        Period: MONTH

  # API Key
  ApiKey:
    Type: AWS::ApiGateway::ApiKey
    Properties:
      Name: !Sub 'ai-scribe-${Stage}-key'
      Description: API key for AI Scribe
      Enabled: true

  # Usage Plan Key
  UsagePlanKey:
    Type: AWS::ApiGateway::UsagePlanKey
    Properties:
      KeyId: !Ref ApiKey
      KeyType: API_KEY
      UsagePlanId: !Ref ApiUsagePlan

  # CloudWatch Log Groups
  ApiLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/ai-scribe-${Stage}'
      RetentionInDays: 30

  WebSocketLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/ai-scribe-ws-${Stage}'
      RetentionInDays: 30

  # Placeholder Lambda function (will be replaced with actual functions)
  PlaceholderFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'ai-scribe-${Stage}-placeholder'
      Runtime: nodejs20.x
      Handler: index.handler
      Code:
        ZipFile: |
          exports.handler = async (event) => {
            return {
              statusCode: 200,
              body: JSON.stringify({ message: 'Placeholder function' })
            };
          };
      Role: !GetAtt PlaceholderFunctionRole.Arn

  PlaceholderFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  AuthorizerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'ai-scribe-${Stage}-ws-authorizer'
      Runtime: nodejs20.x
      Handler: index.handler
      Code:
        ZipFile: |
          const jwt = require('jsonwebtoken');
          
          exports.handler = async (event) => {
            try {
              const token = event.queryStringParameters.token;
              if (!token) {
                return generatePolicy('user', 'Deny', event.methodArn);
              }
              
              // Verify JWT token (placeholder - use actual verification)
              const decoded = jwt.verify(token, process.env.JWT_SECRET);
              
              return generatePolicy(decoded.sub, 'Allow', event.methodArn);
            } catch (error) {
              return generatePolicy('user', 'Deny', event.methodArn);
            }
          };
          
          function generatePolicy(principalId, effect, resource) {
            return {
              principalId,
              policyDocument: {
                Version: '2012-10-17',
                Statement: [{
                  Action: 'execute-api:Invoke',
                  Effect: effect,
                  Resource: resource
                }]
              }
            };
          }
      Role: !GetAtt PlaceholderFunctionRole.Arn
      Environment:
        Variables:
          JWT_SECRET: placeholder

  # Lambda permissions for API Gateway
  ApiGatewayInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PlaceholderFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/*'

  WebSocketApiInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PlaceholderFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'

  AuthorizerInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AuthorizerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*'

  # Custom Domain (optional)
  CustomDomain:
    Type: AWS::ApiGateway::DomainName
    Condition: HasDomainName
    Properties:
      DomainName: !Ref DomainName
      RegionalCertificateArn: !Sub 'arn:aws:acm:${AWS::Region}:${AWS::AccountId}:certificate/*'
      EndpointConfiguration:
        Types:
          - REGIONAL
      SecurityPolicy: TLS_1_2

  BasePathMapping:
    Type: AWS::ApiGateway::BasePathMapping
    Condition: HasDomainName
    Properties:
      DomainName: !Ref CustomDomain
      RestApiId: !Ref RestApi
      Stage: !Ref Stage

Outputs:
  RestApiId:
    Description: REST API ID
    Value: !Ref RestApi

  RestApiArn:
    Description: REST API ARN
    Value: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}'

  ApiUrl:
    Description: API Gateway URL
    Value: !Sub 'https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${Stage}'

  WebSocketUrl:
    Description: WebSocket API URL
    Value: !Sub 'wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${Stage}'

  ApiKeyId:
    Description: API Key ID
    Value: !Ref ApiKey
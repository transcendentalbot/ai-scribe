{"version":3,"file":"audio.service.js","sourceRoot":"","sources":["../../src/services/audio.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { S3Client, PutObjectCommand, CreateMultipartUploadCommand, UploadPartCommand, CompleteMultipartUploadCommand } from '@aws-sdk/client-s3';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, PutCommand, UpdateCommand, GetCommand, DeleteCommand } from '@aws-sdk/lib-dynamodb';\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner';\nimport { v4 as uuidv4 } from 'uuid';\n\nconst s3Client = new S3Client({});\nconst dynamoClient = new DynamoDBClient({});\nconst docClient = DynamoDBDocumentClient.from(dynamoClient);\n\ninterface RecordingSession {\n  sessionId: string;\n  connectionId: string;\n  encounterId: string;\n  startTime: string;\n  uploadId?: string;\n  parts: Array<{ ETag: string; PartNumber: number }>;\n  s3Key: string;\n  isPaused: boolean;\n  totalDuration: number;\n  lastSequenceNumber: number;\n  chunkBuffer: Buffer[];\n  bufferSize: number;\n}\n\nclass AudioService {\n  private readonly bucketName = process.env.AUDIO_BUCKET_NAME!;\n  private readonly tableName = process.env.TABLE_NAME!;\n  private readonly connectionsTable = process.env.CONNECTIONS_TABLE_NAME!;\n  private readonly MIN_PART_SIZE = 5 * 1024 * 1024; // 5MB minimum for S3 multipart\n  private sessionBuffers: Map<string, Buffer[]> = new Map(); // In-memory buffer storage\n\n  // Store session in DynamoDB instead of memory\n  private async storeSession(session: RecordingSession) {\n    // Don't store the buffer in DynamoDB, only metadata\n    const { chunkBuffer, ...sessionWithoutBuffer } = session;\n    await docClient.send(\n      new PutCommand({\n        TableName: this.connectionsTable,\n        Item: {\n          connectionId: `SESSION#${session.sessionId}`,\n          sessionData: JSON.stringify(sessionWithoutBuffer),\n          ttl: Math.floor(Date.now() / 1000) + 3600, // 1 hour TTL\n          timestamp: Date.now(),\n        },\n      })\n    );\n    console.log(`[AudioService] Session ${session.sessionId} stored in DynamoDB`);\n  }\n\n  // Get session from DynamoDB\n  private async getSession(sessionId: string): Promise<RecordingSession | null> {\n    const result = await docClient.send(\n      new GetCommand({\n        TableName: this.connectionsTable,\n        Key: {\n          connectionId: `SESSION#${sessionId}`,\n        },\n      })\n    );\n    \n    if (!result.Item || !result.Item.sessionData) {\n      console.log(`[AudioService] Session not found for ${sessionId}`);\n      return null;\n    }\n    \n    // Parse the stored session data and restore buffer from memory\n    const session = JSON.parse(result.Item.sessionData) as RecordingSession;\n    session.chunkBuffer = this.sessionBuffers.get(sessionId) || [];\n    session.bufferSize = session.bufferSize || 0;\n    console.log(`[AudioService] Retrieved session ${sessionId} from DynamoDB`);\n    return session;\n  }\n\n  // Update session in DynamoDB\n  private async updateSession(sessionId: string, updates: Partial<RecordingSession>) {\n    // Get current session\n    const currentSession = await this.getSession(sessionId);\n    if (!currentSession) {\n      throw new Error(`Cannot update non-existent session: ${sessionId}`);\n    }\n    \n    // Apply updates\n    const updatedSession = { ...currentSession, ...updates };\n    \n    // Don't store the buffer in DynamoDB\n    const { chunkBuffer, ...sessionWithoutBuffer } = updatedSession;\n    \n    // Store updated session\n    await docClient.send(\n      new UpdateCommand({\n        TableName: this.connectionsTable,\n        Key: {\n          connectionId: `SESSION#${sessionId}`,\n        },\n        UpdateExpression: 'SET sessionData = :data',\n        ExpressionAttributeValues: {\n          ':data': JSON.stringify(sessionWithoutBuffer),\n        },\n      })\n    );\n    console.log(`[AudioService] Updated session ${sessionId} in DynamoDB`);\n  }\n\n  // Delete session from DynamoDB\n  private async deleteSession(sessionId: string) {\n    await docClient.send(\n      new DeleteCommand({\n        TableName: this.connectionsTable,\n        Key: {\n          connectionId: `SESSION#${sessionId}`,\n        },\n      })\n    );\n    // Clear in-memory buffer\n    this.sessionBuffers.delete(sessionId);\n    console.log(`[AudioService] Deleted session ${sessionId} from DynamoDB and cleared buffer`);\n  }\n\n  async startRecording({\n    connectionId,\n    encounterId,\n    metadata,\n  }: {\n    connectionId: string;\n    encounterId: string;\n    metadata?: any;\n  }) {\n    const sessionId = uuidv4();\n    const timestamp = new Date().toISOString();\n    const s3Key = `recordings/${encounterId}/${sessionId}/audio.webm`;\n\n    console.log(`[AudioService] Starting recording - sessionId: ${sessionId}, connectionId: ${connectionId}`);\n\n    // Initialize multipart upload\n    const multipartUpload = await s3Client.send(\n      new CreateMultipartUploadCommand({\n        Bucket: this.bucketName,\n        Key: s3Key,\n        ContentType: 'audio/webm',\n        Metadata: {\n          encounterId,\n          sessionId,\n          connectionId,\n          startTime: timestamp,\n          ...(metadata ? Object.entries(metadata).reduce((acc, [key, value]) => ({\n            ...acc,\n            [key]: String(value)\n          }), {}) : {}),\n        },\n        ServerSideEncryption: 'aws:kms',\n      })\n    );\n\n    // Create session\n    const session: RecordingSession = {\n      sessionId,\n      connectionId,\n      encounterId,\n      startTime: timestamp,\n      uploadId: multipartUpload.UploadId,\n      parts: [],\n      s3Key,\n      isPaused: false,\n      totalDuration: 0,\n      lastSequenceNumber: -1,\n      chunkBuffer: [],\n      bufferSize: 0,\n    };\n\n    // Initialize in-memory buffer first\n    this.sessionBuffers.set(sessionId, []);\n    \n    // Store in DynamoDB\n    await this.storeSession(session);\n    console.log(`[AudioService] Session stored in DynamoDB and buffer initialized`);\n\n    // Generate pre-signed URL for direct uploads (optional)\n    const uploadUrl = await getSignedUrl(\n      s3Client,\n      new PutObjectCommand({\n        Bucket: this.bucketName,\n        Key: `${s3Key}.chunks/${sessionId}-chunk-`,\n      }),\n      { expiresIn: 3600 }\n    );\n\n    return {\n      sessionId,\n      uploadUrl,\n      s3Key,\n    };\n  }\n\n  async processAudioChunk({\n    connectionId,\n    sessionId,\n    chunk,\n    sequenceNumber,\n  }: {\n    connectionId: string;\n    sessionId: string;\n    chunk: string; // base64 encoded\n    sequenceNumber: number;\n  }) {\n    console.log(`[AudioService] Processing chunk - sessionId: ${sessionId}, seq: ${sequenceNumber}, connectionId: ${connectionId}`);\n    \n    // Get session from DynamoDB with retry\n    let session = await this.getSession(sessionId);\n    \n    // If session not found, wait a bit and retry once (in case of race condition)\n    if (!session) {\n      console.log(`[AudioService] Session not found on first try, waiting 500ms and retrying...`);\n      await new Promise(resolve => setTimeout(resolve, 500));\n      session = await this.getSession(sessionId);\n    }\n    \n    if (!session) {\n      console.error(`[AudioService] Session not found after retry: ${sessionId}`);\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n    \n    if (session.connectionId !== connectionId) {\n      console.error(`[AudioService] Connection mismatch - expected: ${session.connectionId}, got: ${connectionId}`);\n      throw new Error('Invalid session - connection mismatch');\n    }\n\n    if (session.isPaused) {\n      return { status: 'paused' };\n    }\n\n    // Handle sequence number validation\n    const expectedSequence = session.lastSequenceNumber + 1;\n    \n    if (sequenceNumber < expectedSequence) {\n      // This is a duplicate or late chunk, ignore it\n      console.log(`[AudioService] Ignoring duplicate/late chunk - seq: ${sequenceNumber}, expected: ${expectedSequence}`);\n      return { status: 'duplicate', sequenceNumber };\n    }\n    \n    if (sequenceNumber > expectedSequence) {\n      // This chunk arrived out of order\n      console.warn(`[AudioService] Out of sequence chunk - received: ${sequenceNumber}, expected: ${expectedSequence}`);\n      // For now, we'll accept it but log the gap\n      // In production, you might want to implement a reordering buffer\n    }\n\n    // Convert base64 to buffer\n    const buffer = Buffer.from(chunk, 'base64');\n    \n    // Add to in-memory buffer\n    let buffers = this.sessionBuffers.get(sessionId) || [];\n    buffers.push(buffer);\n    this.sessionBuffers.set(sessionId, buffers);\n    session.bufferSize += buffer.length;\n    console.log(`[AudioService] Added chunk to buffer. Current buffer size: ${session.bufferSize} bytes`);\n    \n    // Check if buffer exceeds minimum part size\n    if (session.bufferSize >= this.MIN_PART_SIZE) {\n      // Combine all buffers\n      const combinedBuffer = Buffer.concat(buffers);\n      \n      // Upload as a part\n      const partNumber = session.parts.length + 1;\n      console.log(`[AudioService] Buffer reached ${session.bufferSize} bytes, uploading as part ${partNumber}`);\n      \n      const uploadPartResult = await s3Client.send(\n        new UploadPartCommand({\n          Bucket: this.bucketName,\n          Key: session.s3Key,\n          UploadId: session.uploadId,\n          PartNumber: partNumber,\n          Body: combinedBuffer,\n        })\n      );\n      \n      console.log(`[AudioService] Part ${partNumber} uploaded successfully, ETag: ${uploadPartResult.ETag}`);\n      \n      // Update session with new part and clear buffer\n      const updatedParts = [...session.parts, {\n        ETag: uploadPartResult.ETag!,\n        PartNumber: partNumber,\n      }];\n      \n      await this.updateSession(sessionId, {\n        parts: updatedParts,\n        lastSequenceNumber: sequenceNumber,\n        bufferSize: 0,\n      });\n      \n      // Clear the in-memory buffer\n      this.sessionBuffers.set(sessionId, []);\n    } else {\n      // Just update the sequence number and buffer size\n      await this.updateSession(sessionId, {\n        lastSequenceNumber: sequenceNumber,\n        bufferSize: session.bufferSize,\n      });\n    }\n\n    return { status: 'processed', sequenceNumber };\n  }\n\n  async stopRecording({\n    connectionId,\n    sessionId,\n  }: {\n    connectionId: string;\n    sessionId: string;\n  }) {\n    console.log(`[AudioService] Stopping recording for session: ${sessionId}`);\n    \n    // Get session from DynamoDB\n    const session = await this.getSession(sessionId);\n    \n    if (!session) {\n      console.error(`[AudioService] Session not found: ${sessionId}`);\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n    \n    if (session.connectionId !== connectionId) {\n      console.error(`[AudioService] Connection mismatch. Expected: ${session.connectionId}, Got: ${connectionId}`);\n      throw new Error('Invalid session - connection mismatch');\n    }\n\n    console.log(`[AudioService] Session found. Parts uploaded: ${session.parts.length}, Buffer size: ${session.bufferSize}`);\n\n    // Upload any remaining buffered data\n    if (session.bufferSize > 0) {\n      const buffers = this.sessionBuffers.get(sessionId) || [];\n      if (buffers.length > 0) {\n        console.log(`[AudioService] Uploading remaining buffer of ${session.bufferSize} bytes as final part`);\n        \n        const combinedBuffer = Buffer.concat(buffers);\n        const finalPartNumber = session.parts.length + 1;\n        \n        // Upload the final part (can be less than 5MB)\n        const uploadPartResult = await s3Client.send(\n          new UploadPartCommand({\n            Bucket: this.bucketName,\n            Key: session.s3Key,\n            UploadId: session.uploadId,\n            PartNumber: finalPartNumber,\n            Body: combinedBuffer,\n          })\n        );\n        \n        console.log(`[AudioService] Final part ${finalPartNumber} uploaded successfully, ETag: ${uploadPartResult.ETag}`);\n        \n        // Add the final part to the parts list\n        session.parts.push({\n          ETag: uploadPartResult.ETag!,\n          PartNumber: finalPartNumber,\n        });\n      }\n    }\n\n    // Only complete multipart upload if we have parts\n    if (session.parts.length === 0) {\n      console.warn(`[AudioService] No parts uploaded for session ${sessionId}`);\n      // Clean up the multipart upload\n      await this.deleteSession(sessionId);\n      throw new Error('No audio data was recorded');\n    }\n\n    console.log(`[AudioService] Completing multipart upload with ${session.parts.length} parts`);\n    // Complete multipart upload\n    await s3Client.send(\n      new CompleteMultipartUploadCommand({\n        Bucket: this.bucketName,\n        Key: session.s3Key,\n        UploadId: session.uploadId,\n        MultipartUpload: {\n          Parts: session.parts,\n        },\n      })\n    );\n\n    // Calculate duration\n    const endTime = new Date();\n    const startTime = new Date(session.startTime);\n    const duration = Math.floor((endTime.getTime() - startTime.getTime()) / 1000);\n\n    // Create recording record\n    const recordingId = uuidv4();\n    await docClient.send(\n      new UpdateCommand({\n        TableName: this.tableName,\n        Key: {\n          pk: `ENCOUNTER#${session.encounterId}`,\n          sk: 'METADATA',\n        },\n        UpdateExpression: 'SET recordings = list_append(if_not_exists(recordings, :empty), :recording)',\n        ExpressionAttributeValues: {\n          ':empty': [],\n          ':recording': [{\n            id: recordingId,\n            startTime: session.startTime,\n            endTime: endTime.toISOString(),\n            duration,\n            s3Key: session.s3Key,\n            transcriptionId: null,\n          }],\n        },\n      })\n    );\n\n    // Clean up session from DynamoDB and in-memory buffer\n    await this.deleteSession(sessionId);\n\n    return {\n      recordingId,\n      duration,\n      s3Key: session.s3Key,\n      encounterId: session.encounterId,\n    };\n  }\n\n  async updateRecordingStatus({\n    connectionId,\n    sessionId,\n    isPaused,\n  }: {\n    connectionId: string;\n    sessionId: string;\n    isPaused: boolean;\n  }) {\n    const session = await this.getSession(sessionId);\n    \n    if (!session || session.connectionId !== connectionId) {\n      throw new Error('Invalid session');\n    }\n\n    await this.updateSession(sessionId, { isPaused });\n    return { status: isPaused ? 'paused' : 'resumed' };\n  }\n}\n\nexport const audioService = new AudioService();"]}
{"version":3,"file":"audio-stream.js","sourceRoot":"","sources":["../../../src/handlers/websocket/audio-stream.ts"],"names":[],"mappings":"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","sourcesContent":["import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, GetCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';\nimport { ApiGatewayManagementApiClient, PostToConnectionCommand } from '@aws-sdk/client-apigatewaymanagementapi';\nimport { audioService } from '../../services/audio.service';\nimport { transcriptionService } from '../../services/transcription.service';\n\nconst dynamoClient = new DynamoDBClient({});\nconst docClient = DynamoDBDocumentClient.from(dynamoClient);\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise<APIGatewayProxyResult> => {\n  const connectionId = event.requestContext.connectionId!;\n  const routeKey = event.requestContext.routeKey;\n  \n  // Create API Gateway Management API client\n  const apigwManagementApi = new ApiGatewayManagementApiClient({\n    endpoint: `https://${event.requestContext.domainName}/${event.requestContext.stage}`,\n  });\n\n  try {\n    const body = JSON.parse(event.body || '{}');\n\n    // Verify connection exists\n    const connectionResult = await docClient.send(\n      new GetCommand({\n        TableName: process.env.CONNECTIONS_TABLE_NAME!,\n        Key: { connectionId },\n      })\n    );\n\n    if (!connectionResult.Item) {\n      return {\n        statusCode: 401,\n        body: JSON.stringify({ message: 'Connection not found' }),\n      };\n    }\n\n    // Handle different audio stream actions\n    // The 'action' field is used for routing, so we use 'type' for the sub-action\n    const subAction = body.type || body.action;\n    switch (subAction) {\n      case 'start-recording': {\n        const { encounterId, metadata, enableTranscription = true } = body;\n        \n        // Initialize recording session\n        const audioSession = await audioService.startRecording({\n          connectionId,\n          encounterId,\n          metadata,\n        });\n\n        let transcriptionSession = null;\n        if (enableTranscription) {\n          try {\n            // Start transcription session\n            transcriptionSession = await transcriptionService.startTranscription({\n              connectionId,\n              encounterId,\n              metadata,\n              apiGatewayClient: apigwManagementApi,\n            });\n          } catch (error) {\n            console.error('[start-recording] Failed to start transcription:', error);\n            // Continue without transcription\n          }\n        }\n\n        // Update connection with recording and transcription info\n        await docClient.send(\n          new UpdateCommand({\n            TableName: process.env.CONNECTIONS_TABLE_NAME!,\n            Key: { connectionId },\n            UpdateExpression: 'SET recordingSession = :recording, transcriptionSession = :transcription, #status = :status',\n            ExpressionAttributeNames: {\n              '#status': 'status',\n            },\n            ExpressionAttributeValues: {\n              ':recording': audioSession,\n              ':transcription': transcriptionSession,\n              ':status': 'recording',\n            },\n          })\n        );\n\n        // Send confirmation back to client\n        await apigwManagementApi.send(\n          new PostToConnectionCommand({\n            ConnectionId: connectionId,\n            Data: JSON.stringify({\n              type: 'recording-started',\n              sessionId: audioSession.sessionId,\n              transcriptionSessionId: transcriptionSession?.sessionId,\n              uploadUrl: audioSession.uploadUrl,\n              enableTranscription,\n            }),\n          })\n        );\n        break;\n      }\n\n      case 'audio-chunk': {\n        const { sessionId, chunk, sequenceNumber, transcriptionSessionId } = body;\n        \n        try {\n          // Process audio chunk for recording\n          const recordingResult = await audioService.processAudioChunk({\n            connectionId,\n            sessionId,\n            chunk,\n            sequenceNumber,\n          });\n\n          // Only process for transcription if not a duplicate\n          if (transcriptionSessionId && recordingResult.status !== 'duplicate') {\n            try {\n              // Send audio chunks to live transcription\n              const transcript = await transcriptionService.processAudioChunk({\n                sessionId: transcriptionSessionId,\n                chunk,\n                sequenceNumber,\n              });\n              \n              // Note: Live transcripts are sent directly via WebSocket from the transcription service\n              // No need to handle the response here\n            } catch (transcriptionError) {\n              console.error('[audio-chunk] Transcription error:', transcriptionError);\n              // Continue processing even if transcription fails\n            }\n          }\n\n          // Send acknowledgment\n          await apigwManagementApi.send(\n            new PostToConnectionCommand({\n              ConnectionId: connectionId,\n              Data: JSON.stringify({\n                type: 'chunk-received',\n                sequenceNumber,\n                status: recordingResult.status,\n                transcribed: false,\n              }),\n            })\n          );\n        } catch (chunkError: any) {\n          // If session not found, it might be a late-arriving chunk after stop\n          if (chunkError.message?.includes('Session not found')) {\n            console.log(`[audio-chunk] Late chunk ignored for completed session: ${sessionId}, seq: ${sequenceNumber}`);\n            // Still send acknowledgment to avoid client retries\n            await apigwManagementApi.send(\n              new PostToConnectionCommand({\n                ConnectionId: connectionId,\n                Data: JSON.stringify({\n                  type: 'chunk-received',\n                  sequenceNumber,\n                  late: true,\n                }),\n              })\n            );\n          } else {\n            // Re-throw other errors\n            throw chunkError;\n          }\n        }\n        break;\n      }\n\n      case 'stop-recording': {\n        const { sessionId, transcriptionSessionId } = body;\n        console.log(`[stop-recording] Processing stop for sessions:`, { sessionId, transcriptionSessionId });\n        \n        try {\n          // Finalize recording first to get the S3 key\n          const recordingResult = await audioService.stopRecording({\n            connectionId,\n            sessionId,\n          });\n          console.log(`[stop-recording] Recording finalized:`, recordingResult);\n\n          // Stop transcription session\n          let transcriptionResult = null;\n          if (transcriptionSessionId) {\n            try {\n              // Stop the live transcription session\n              transcriptionResult = await transcriptionService.stopTranscription({\n                sessionId: transcriptionSessionId,\n              });\n              console.log(`[stop-recording] Live transcription stopped:`, transcriptionResult);\n              \n              // Only transcribe from S3 if we didn't get any live transcripts\n              if (transcriptionResult.transcriptCount === 0 && recordingResult.s3Key) {\n                console.log(`[stop-recording] No live transcripts found, falling back to S3 transcription`);\n                transcriptionResult = await transcriptionService.transcribeFromS3({\n                  sessionId: transcriptionSessionId,\n                  s3Key: recordingResult.s3Key,\n                  encounterId: recordingResult.encounterId,\n                });\n                console.log(`[stop-recording] S3 transcription completed:`, transcriptionResult);\n              }\n            } catch (transcriptionError) {\n              console.error(`[stop-recording] Transcription error:`, transcriptionError);\n            }\n          }\n\n          // Update connection status\n          await docClient.send(\n            new UpdateCommand({\n              TableName: process.env.CONNECTIONS_TABLE_NAME!,\n              Key: { connectionId },\n              UpdateExpression: 'SET #status = :status, recordingSession = :empty, transcriptionSession = :empty',\n              ExpressionAttributeNames: {\n                '#status': 'status',\n              },\n              ExpressionAttributeValues: {\n                ':status': 'connected',\n                ':empty': null,\n              },\n            })\n          );\n          console.log(`[stop-recording] Connection status updated`);\n\n          // Send completion notification\n          const responseData = {\n            type: 'recording-stopped',\n            sessionId,\n            recordingId: recordingResult.recordingId,\n            duration: recordingResult.duration,\n            s3Key: recordingResult.s3Key,\n            transcriptionSessionId,\n            transcriptCount: transcriptionResult?.transcriptCount || 0,\n          };\n          console.log(`[stop-recording] Sending response:`, responseData);\n          \n          await apigwManagementApi.send(\n            new PostToConnectionCommand({\n              ConnectionId: connectionId,\n              Data: JSON.stringify(responseData),\n            })\n          );\n          console.log(`[stop-recording] Response sent successfully`);\n        } catch (error) {\n          console.error(`[stop-recording] Error processing stop:`, error);\n          throw error;\n        }\n        break;\n      }\n\n      case 'pause-recording':\n      case 'resume-recording': {\n        const { sessionId } = body;\n        const isPaused = subAction === 'pause-recording';\n        \n        await audioService.updateRecordingStatus({\n          connectionId,\n          sessionId,\n          isPaused,\n        });\n\n        await apigwManagementApi.send(\n          new PostToConnectionCommand({\n            ConnectionId: connectionId,\n            Data: JSON.stringify({\n              type: isPaused ? 'recording-paused' : 'recording-resumed',\n              sessionId,\n            }),\n          })\n        );\n        break;\n      }\n\n      default:\n        return {\n          statusCode: 400,\n          body: JSON.stringify({ message: 'Invalid action' }),\n        };\n    }\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ message: 'Success' }),\n    };\n  } catch (error) {\n    console.error('Error processing audio stream:', error);\n    \n    // Send error notification to client\n    try {\n      await apigwManagementApi.send(\n        new PostToConnectionCommand({\n          ConnectionId: connectionId,\n          Data: JSON.stringify({\n            type: 'error',\n            message: 'Failed to process audio stream',\n          }),\n        })\n      );\n    } catch (notifyError) {\n      console.error('Failed to notify client of error:', notifyError);\n    }\n\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Internal server error' }),\n    };\n  }\n};"]}
{"version":3,"file":"create-encounter.js","sourceRoot":"","sources":["../../../src/handlers/encounters/create-encounter.ts"],"names":[],"mappings":"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","sourcesContent":["import { APIGatewayProxyEvent, Context } from 'aws-lambda';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';\nimport { CreateEncounterSchema } from '../../types/encounter';\nimport { EncounterService } from '../../services/encounter.service';\nimport { PatientService } from '../../services/patient.service';\nimport { errorHandler } from '../../middleware/error-handler';\nimport { validateBody, getAuthToken } from '../../middleware/request-validator';\nimport { response } from '../../utils/response';\nimport { logger } from '../../utils/logger';\nimport { metrics } from '../../utils/metrics';\nimport { cognitoService } from '../../utils/cognito';\nimport { AuthorizationError, NotFoundError, ValidationError } from '../../errors';\nimport jwt from 'jsonwebtoken';\nimport crypto from 'crypto';\n\nconst dynamoClient = new DynamoDBClient({});\nconst dynamodb = DynamoDBDocumentClient.from(dynamoClient);\nconst encounterService = new EncounterService(dynamodb, process.env.TABLE_NAME!);\nconst patientService = new PatientService(dynamodb, process.env.TABLE_NAME!);\n\n// Simple encryption for PHI (in production, use AWS KMS)\nconst encryptPHI = (text: string): string => {\n  const algorithm = 'aes-256-cbc';\n  const key = crypto.scryptSync(process.env.ENCRYPTION_KEY || 'default-key', 'salt', 32);\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return iv.toString('hex') + ':' + encrypted;\n};\n\nconst createEncounterHandler = async (event: APIGatewayProxyEvent, context: Context) => {\n  const startTime = Date.now();\n  const requestId = context.awsRequestId;\n  \n  logger.info('[CREATE_ENCOUNTER] Handler started', {\n    requestId,\n    timestamp: new Date().toISOString(),\n    method: event.httpMethod,\n    path: event.path,\n    userAgent: event.headers['User-Agent'],\n    origin: event.headers.Origin\n  });\n  \n  // Get provider ID from token\n  logger.info('[CREATE_ENCOUNTER] Extracting token', { requestId });\n  const token = getAuthToken(event);\n  \n  logger.info('[CREATE_ENCOUNTER] Decoding token', { requestId, hasToken: !!token });\n  // Decode the access token to get the user ID\n  const decodedToken = jwt.decode(token) as any;\n  const providerId = decodedToken?.sub || decodedToken?.username;\n  \n  logger.info('[CREATE_ENCOUNTER] Provider extracted', { requestId, providerId: providerId ? 'PRESENT' : 'MISSING' });\n  \n  if (!providerId) {\n    logger.error('[CREATE_ENCOUNTER] No provider ID found', { requestId, decodedToken });\n    throw new AuthorizationError('Provider ID not found');\n  }\n\n  // Validate request body\n  logger.info('[CREATE_ENCOUNTER] Validating request body', { requestId, bodyLength: event.body?.length || 0 });\n  const encounterData = validateBody(event, CreateEncounterSchema);\n  logger.info('[CREATE_ENCOUNTER] Request body validated successfully', { \n    requestId, \n    type: encounterData.type,\n    hasPatientId: !!encounterData.patientId,\n    hasPatientName: !!encounterData.patientName,\n    hasPatientMRN: !!encounterData.patientMRN\n  });\n\n  // Check consent\n  logger.info('[CREATE_ENCOUNTER] Checking consent', { requestId, consentObtained: encounterData.consentObtained });\n  if (!encounterData.consentObtained) {\n    logger.error('[CREATE_ENCOUNTER] Consent not obtained', { requestId });\n    throw new ValidationError('Consent must be obtained before creating an encounter');\n  }\n\n  logger.info('[CREATE_ENCOUNTER] Starting encounter creation process', {\n    requestId,\n    providerId: providerId ? 'PRESENT' : 'MISSING',\n    type: encounterData.type,\n    hasPatientId: !!encounterData.patientId,\n    hasPatientInfo: !!(encounterData.patientName && encounterData.patientMRN)\n  });\n\n  let patientId = encounterData.patientId;\n\n  // If no patient ID, check if we need to create or find patient\n  if (!patientId && encounterData.patientName && encounterData.patientMRN) {\n    logger.info('[CREATE_ENCOUNTER] No patient ID provided, checking for existing patient', { \n      requestId, \n      patientMRN: encounterData.patientMRN \n    });\n    \n    // Check if patient with MRN exists\n    const existingPatient = await patientService.getPatientByMrn(encounterData.patientMRN);\n    logger.info('[CREATE_ENCOUNTER] Patient lookup complete', { \n      requestId, \n      found: !!existingPatient,\n      patientId: existingPatient?.id \n    });\n    \n    if (existingPatient) {\n      patientId = existingPatient.id;\n      logger.info('[CREATE_ENCOUNTER] Using existing patient', { requestId, patientId });\n    } else {\n      logger.info('[CREATE_ENCOUNTER] Creating new patient', { requestId });\n      // Create new patient with minimal info\n      const newPatient = await patientService.createPatient({\n        firstName: encounterData.patientName.split(' ')[0] || encounterData.patientName,\n        lastName: encounterData.patientName.split(' ').slice(1).join(' ') || '',\n        mrn: encounterData.patientMRN,\n        dateOfBirth: encounterData.patientBirthdate || '1900-01-01', // Use provided birthdate or placeholder\n        gender: 'Unknown',\n        encryptedName: encryptPHI(encounterData.patientName),\n        encryptedMrn: encryptPHI(encounterData.patientMRN),\n      } as any, providerId);\n      patientId = newPatient.id;\n      logger.info('[CREATE_ENCOUNTER] New patient created', { requestId, patientId });\n    }\n  }\n\n  if (!patientId) {\n    logger.error('[CREATE_ENCOUNTER] No patient ID resolved', { requestId });\n    throw new ValidationError('Either patient ID or patient name/MRN must be provided');\n  }\n\n  logger.info('[CREATE_ENCOUNTER] Creating encounter in database', { requestId, patientId });\n  // Create encounter with the resolved patient ID\n  const encounter = await encounterService.createEncounter({\n    type: encounterData.type,\n    consentObtained: encounterData.consentObtained || false,\n    patientId,\n    scheduledAt: new Date().toISOString(), // Set to now for immediate encounters\n  }, providerId);\n  \n  logger.info('[CREATE_ENCOUNTER] Encounter created successfully', { \n    requestId, \n    encounterId: encounter.id,\n    patientId: encounter.patientId \n  });\n\n  // Log PHI access\n  logger.info('[CREATE_ENCOUNTER] Logging PHI access audit', { requestId });\n  logger.audit('ENCOUNTER_CREATED', providerId, encounter.id, {\n    patientId: encounter.patientId,\n    action: 'CREATE',\n  });\n\n  // Track metrics\n  logger.info('[CREATE_ENCOUNTER] Recording metrics', { requestId });\n  metrics.success('CreateEncounter');\n  metrics.duration('CreateEncounterDuration', startTime);\n  metrics.count('EncounterType', 1, 'Count', { Type: encounter.type });\n\n  logger.info('[CREATE_ENCOUNTER] Preparing response', { \n    requestId, \n    encounterId: encounter.id,\n    duration: Date.now() - startTime \n  });\n\n  const responseData = {\n    encounter,\n  };\n  \n  logger.info('[CREATE_ENCOUNTER] Sending response', { \n    requestId, \n    statusCode: 201,\n    responseSize: JSON.stringify(responseData).length,\n    totalDuration: Date.now() - startTime \n  });\n\n  return response.success(responseData, 201);\n};\n\nexport const handler = errorHandler(createEncounterHandler);"]}
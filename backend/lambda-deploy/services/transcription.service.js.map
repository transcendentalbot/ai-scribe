{"version":3,"file":"transcription.service.js","sourceRoot":"","sources":["../../src/services/transcription.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, PutCommand, GetCommand, DeleteCommand, QueryCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';\nimport { TranscribeClient, StartMedicalTranscriptionJobCommand } from '@aws-sdk/client-transcribe';\nimport { S3Client, PutObjectCommand, DeleteObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\nimport { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';\nimport { createClient } from '@deepgram/sdk';\nimport { v4 as uuidv4 } from 'uuid';\n\nconst dynamoClient = new DynamoDBClient({});\nconst docClient = DynamoDBDocumentClient.from(dynamoClient);\nconst transcribeClient = new TranscribeClient({});\nconst secretsClient = new SecretsManagerClient({});\n\n// DynamoDB-based session storage\nconst SESSION_TABLE_PREFIX = 'TRANSCRIPTION_SESSION#';\n\n// Deepgram configuration\nconst DEEPGRAM_SECRET_NAME = process.env.DEEPGRAM_SECRET_NAME || '';\nconst DEEPGRAM_MEDICAL_MODEL = 'nova-2-medical';\nconst DEEPGRAM_GENERAL_MODEL = 'nova-2-general'; // Fallback model\nconst BUFFER_DURATION_MS = 2000; // 2 seconds for more real-time feel\nconst BUFFER_SIZE_BYTES = 32000; // ~2 seconds at 16kHz\n\n// Cache for Deepgram client to avoid repeated secret fetches\nlet deepgramClient: any = null;\nlet deepgramApiKey: string = '';\n\n// Map to store active Deepgram live connections\nconst liveConnections = new Map<string, any>();\n\n// Map to store WebSocket management clients for sending transcripts\nconst wsClients = new Map<string, { connectionId: string; apiGatewayClient: any }>();\n\ninterface TranscriptionSession {\n  sessionId: string;\n  connectionId: string;\n  encounterId: string;\n  startTime: number;\n  endTime?: number;\n  status: 'active' | 'completed';\n  provider: 'deepgram' | 'aws-transcribe';\n  audioBuffer: Buffer[];\n  bufferSize: number;\n  lastProcessedTime: number;\n}\n\ninterface TranscriptionSegment {\n  encounterId: string;\n  timestamp: number;\n  text: string;\n  speaker?: string;\n  confidence?: number;\n  entities?: Array<{\n    type: 'medication' | 'symptom' | 'vital' | 'condition';\n    text: string;\n    value?: string;\n    unit?: string;\n    attributes?: Record<string, unknown>;\n  }>;\n  isPartial?: boolean;\n}\n\nclass TranscriptionService {\n  async transcribeFromS3(params: {\n    sessionId: string;\n    s3Key: string;\n    encounterId: string;\n  }): Promise<{ transcriptCount: number; segments: TranscriptionSegment[] }> {\n    console.log(`[Transcription] Transcribing from S3: ${params.s3Key}`);\n    \n    const s3Client = new S3Client({});\n    \n    try {\n      // Get the audio file from S3\n      const getObjectResponse = await s3Client.send(new GetObjectCommand({\n        Bucket: process.env.AUDIO_BUCKET_NAME!,\n        Key: params.s3Key,\n      }));\n      \n      if (!getObjectResponse.Body) {\n        throw new Error('No audio data found in S3');\n      }\n\n      // Convert stream to buffer\n      const chunks: Uint8Array[] = [];\n      for await (const chunk of getObjectResponse.Body as any) {\n        chunks.push(chunk);\n      }\n      const audioBuffer = Buffer.concat(chunks);\n      \n      console.log(`[Transcription] Downloaded audio from S3, size: ${audioBuffer.length} bytes`);\n\n      // Get Deepgram client\n      const client = await this.getDeepgramClient();\n      if (!client) {\n        throw new Error('Deepgram client not available');\n      }\n\n      // Transcribe the complete audio file\n      const response = await client.listen.prerecorded.transcribeFile(audioBuffer, {\n        model: DEEPGRAM_MEDICAL_MODEL,\n        punctuate: true,\n        diarize: true,\n        language: 'en-US',\n        smart_format: true,\n        utterances: true,\n        // Let Deepgram auto-detect the WebM format\n        mimetype: 'audio/webm',\n      });\n\n      const segments: TranscriptionSegment[] = [];\n      \n      if (response.result?.results?.channels?.[0]?.alternatives?.[0]) {\n        const alternative = response.result.results.channels[0].alternatives[0];\n        \n        if (alternative.transcript && alternative.transcript.trim().length > 0) {\n          // If we have utterances, create segments for each\n          if (response.result.results.utterances && response.result.results.utterances.length > 0) {\n            for (const utterance of response.result.results.utterances) {\n              const segment: TranscriptionSegment = {\n                encounterId: params.encounterId,\n                timestamp: Date.now(),\n                text: utterance.transcript,\n                speaker: this.mapSpeakerLabel(utterance.speaker || 0),\n                confidence: utterance.confidence || alternative.confidence,\n                entities: this.extractMedicalEntities(utterance.transcript),\n                isPartial: false,\n              };\n              segments.push(segment);\n              await this.saveTranscriptionSegment(segment);\n              \n              // Send to WebSocket client\n              // TODO: Implement WebSocket notification\n            }\n          } else {\n            // Single segment for the whole transcript\n            const segment: TranscriptionSegment = {\n              encounterId: params.encounterId,\n              timestamp: Date.now(),\n              text: alternative.transcript,\n              speaker: 'Unknown',\n              confidence: alternative.confidence,\n              entities: this.extractMedicalEntities(alternative.transcript),\n              isPartial: false,\n            };\n            segments.push(segment);\n            await this.saveTranscriptionSegment(segment);\n          }\n        }\n      }\n\n      // Clean up the transcription session\n      await this.stopTranscription({ sessionId: params.sessionId });\n\n      return {\n        transcriptCount: segments.length,\n        segments,\n      };\n    } catch (error) {\n      console.error('[Transcription] Error transcribing from S3:', error);\n      throw error;\n    }\n  }\n  async getDeepgramClient() {\n    if (!deepgramClient && DEEPGRAM_SECRET_NAME) {\n      try {\n        console.log(`[Deepgram] Loading API key from secret: ${DEEPGRAM_SECRET_NAME}`);\n        const secretResponse = await secretsClient.send(\n          new GetSecretValueCommand({\n            SecretId: DEEPGRAM_SECRET_NAME,\n          })\n        );\n\n        if (secretResponse.SecretString) {\n          deepgramApiKey = secretResponse.SecretString;\n          console.log(`[Deepgram] API key loaded successfully`);\n          deepgramClient = createClient(deepgramApiKey);\n        } else {\n          console.warn(`[Deepgram] Secret ${DEEPGRAM_SECRET_NAME} has no value`);\n        }\n      } catch (error) {\n        console.error(`[Deepgram] Failed to load API key from secret:`, error);\n      }\n    }\n\n    return deepgramClient;\n  }\n\n  async saveSession(session: TranscriptionSession) {\n    const item = {\n      pk: `${SESSION_TABLE_PREFIX}${session.sessionId}`,\n      sk: 'SESSION',\n      ...session,\n      // Convert buffer array to base64 strings for DynamoDB storage\n      audioBuffer: session.audioBuffer.map(buf => buf.toString('base64')),\n      ttl: Math.floor(Date.now() / 1000) + (24 * 60 * 60), // 24 hours TTL\n    };\n\n    await docClient.send(\n      new PutCommand({\n        TableName: process.env.TABLE_NAME,\n        Item: item,\n      })\n    );\n  }\n\n  async getSession(sessionId: string): Promise<TranscriptionSession | null> {\n    const result = await docClient.send(\n      new GetCommand({\n        TableName: process.env.TABLE_NAME,\n        Key: {\n          pk: `${SESSION_TABLE_PREFIX}${sessionId}`,\n          sk: 'SESSION',\n        },\n      })\n    );\n\n    if (!result.Item) {\n      return null;\n    }\n\n    // Convert base64 strings back to buffers\n    const session = {\n      ...result.Item,\n      audioBuffer: (result.Item.audioBuffer || []).map((base64: string) =>\n        Buffer.from(base64, 'base64')\n      ),\n    } as TranscriptionSession;\n\n    return session;\n  }\n\n  async deleteSession(sessionId: string) {\n    await docClient.send(\n      new DeleteCommand({\n        TableName: process.env.TABLE_NAME,\n        Key: {\n          pk: `${SESSION_TABLE_PREFIX}${sessionId}`,\n          sk: 'SESSION',\n        },\n      })\n    );\n  }\n\n  async startTranscription(params: {\n    connectionId: string;\n    encounterId: string;\n    metadata?: any;\n    apiGatewayClient?: any;\n  }): Promise<TranscriptionSession> {\n    const sessionId = uuidv4();\n    const session: TranscriptionSession = {\n      sessionId,\n      connectionId: params.connectionId,\n      encounterId: params.encounterId,\n      startTime: Date.now(),\n      status: 'active',\n      provider: 'deepgram',\n      audioBuffer: [],\n      bufferSize: 0,\n      lastProcessedTime: Date.now(),\n    };\n\n    console.log(`[Transcription] Starting session ${sessionId} for encounter ${params.encounterId}`);\n    \n    // Initialize Deepgram live connection\n    try {\n      const client = await this.getDeepgramClient();\n      if (!client) {\n        throw new Error('Deepgram client not available');\n      }\n\n      // Create live transcription connection\n      const connection = client.listen.live({\n        model: DEEPGRAM_MEDICAL_MODEL,\n        punctuate: true,\n        interim_results: true,\n        diarize: true,\n        language: 'en-US',\n        encoding: 'opus',  // Changed from linear16 to opus\n        sample_rate: 16000,\n        channels: 1,\n        endpointing: 300,\n        utterance_end_ms: 1000,\n        vad_events: true,\n        smart_format: true,\n      });\n\n      // Set up event handlers\n      connection.on('open', () => {\n        console.log(`[Deepgram] Live connection opened for session ${sessionId}`);\n      });\n\n      connection.on('error', (error: any) => {\n        console.error(`[Deepgram] Live connection error for session ${sessionId}:`, error);\n      });\n\n      connection.on('close', () => {\n        console.log(`[Deepgram] Live connection closed for session ${sessionId}`);\n        liveConnections.delete(sessionId);\n      });\n\n      connection.on('transcript.partial', (data: any) => {\n        this.handleTranscriptEvent(session, data, true);\n      });\n\n      connection.on('transcript', (data: any) => {\n        this.handleTranscriptEvent(session, data, false);\n      });\n\n      connection.on('utterance_end', (data: any) => {\n        console.log(`[Deepgram] Utterance end for session ${sessionId}`);\n      });\n\n      // Store the connection\n      liveConnections.set(sessionId, connection);\n      \n      // Store WebSocket client info if provided\n      if (params.apiGatewayClient) {\n        wsClients.set(sessionId, {\n          connectionId: params.connectionId,\n          apiGatewayClient: params.apiGatewayClient\n        });\n      }\n      \n    } catch (error) {\n      console.error(`[Transcription] Failed to create Deepgram live connection:`, error);\n      // Continue without live transcription - will fall back to batch processing\n    }\n\n    await this.saveSession(session);\n    return session;\n  }\n\n  async processAudioChunk(params: {\n    sessionId: string;\n    chunk: string; // Base64 encoded audio\n    sequenceNumber: number;\n  }): Promise<TranscriptionSegment | null> {\n    const session = await this.getSession(params.sessionId);\n    if (!session) {\n      throw new Error(`Transcription session ${params.sessionId} not found`);\n    }\n\n    if (session.status !== 'active') {\n      throw new Error(`Transcription session ${params.sessionId} is not active`);\n    }\n\n    // Get the live connection\n    const connection = liveConnections.get(params.sessionId);\n    if (connection && connection.getReadyState() === 1) {\n      // Send audio directly to Deepgram live connection\n      try {\n        // Decode base64 audio chunk\n        const audioBuffer = Buffer.from(params.chunk, 'base64');\n        \n        // For live streaming, we need to convert WebM/Opus to PCM\n        // This is a simplified approach - in production you'd use a proper audio decoder\n        // For now, we'll just send the raw data and let Deepgram handle it\n        connection.send(audioBuffer);\n        \n        // No immediate return - transcripts come through event handlers\n        return null;\n      } catch (error) {\n        console.error(`[Transcription] Error sending to live connection:`, error);\n      }\n    }\n    \n    // Fallback to buffering for batch processing\n    const audioBuffer = Buffer.from(params.chunk, 'base64');\n    session.audioBuffer.push(audioBuffer);\n    session.bufferSize += audioBuffer.length;\n\n    // Check if we've buffered enough audio\n    const shouldProcess = \n      session.bufferSize >= BUFFER_SIZE_BYTES ||\n      Date.now() - session.lastProcessedTime >= BUFFER_DURATION_MS;\n\n    if (!shouldProcess) {\n      // Save updated session back to DynamoDB\n      await this.saveSession(session);\n      return null; // Continue buffering\n    }\n\n    console.log(`[Transcription] Processing buffered audio - ${session.audioBuffer.length} chunks, ${session.bufferSize} bytes`);\n\n    // Combine buffered audio\n    const combinedBuffer = Buffer.concat(session.audioBuffer);\n    session.audioBuffer = [];\n    session.bufferSize = 0;\n    session.lastProcessedTime = Date.now();\n\n    // Save updated session back to DynamoDB\n    await this.saveSession(session);\n\n    try {\n      // Try Deepgram first\n      const segment = await this.transcribeWithDeepgram(session, combinedBuffer);\n      if (segment) {\n        await this.saveTranscriptionSegment(segment);\n        return segment;\n      }\n    } catch (error) {\n      console.error('[Transcription] Deepgram failed:', error);\n    }\n\n    return null;\n  }\n\n  async transcribeWithDeepgram(session: TranscriptionSession, audioBuffer: Buffer): Promise<TranscriptionSegment | null> {\n    const client = await this.getDeepgramClient();\n    if (!client) {\n      console.warn('[Deepgram] Client not initialized - API key missing');\n      return null;\n    }\n\n    try {\n      let response;\n      let modelUsed = DEEPGRAM_MEDICAL_MODEL;\n\n      try {\n        console.log(`[Deepgram] Attempting transcription with medical model: ${DEEPGRAM_MEDICAL_MODEL}`);\n        response = await client.listen.prerecorded.transcribeFile(audioBuffer, {\n          model: DEEPGRAM_MEDICAL_MODEL,\n          punctuate: true,\n          diarize: true,\n          language: 'en-US',\n          smart_format: true,\n          utterances: true,\n          encoding: 'webm-opus',\n          sample_rate: 16000,\n          channels: 1,\n          vad_events: true,\n          interim_results: false,\n          endpointing: false,\n          keywords: ['pain:2', 'medication:2', 'treatment:2', 'doctor:3', 'patient:3'],\n          detect_language: false,\n        });\n      } catch (medicalModelError) {\n        console.warn(`[Deepgram] Medical model failed, trying general model:`, medicalModelError);\n        modelUsed = DEEPGRAM_GENERAL_MODEL;\n        response = await client.listen.prerecorded.transcribeFile(audioBuffer, {\n          model: DEEPGRAM_GENERAL_MODEL,\n          punctuate: true,\n          diarize: true,\n          language: 'en-US',\n          smart_format: true,\n          utterances: true,\n          encoding: 'webm-opus',\n          sample_rate: 16000,\n          channels: 1,\n          vad_events: true,\n          interim_results: false,\n          endpointing: false,\n          detect_language: false,\n        });\n      }\n\n      console.log(`[Deepgram] Transcription completed using model: ${modelUsed}`);\n      const result = response.result;\n\n      if (result?.results?.channels?.[0]?.alternatives?.[0]) {\n        const alternative = result.results.channels[0].alternatives[0];\n        const words = alternative.words || [];\n\n        // Check if transcript is empty\n        if (!alternative.transcript || alternative.transcript.trim().length === 0) {\n          console.warn(`[Deepgram] Empty transcript detected`);\n          return null;\n        }\n\n        // Extract speaker labels from diarization\n        let speaker = 'Unknown';\n        if (words.length > 0 && words[0].speaker !== undefined) {\n          speaker = this.identifySpeaker(words, alternative.transcript, session);\n        }\n\n        const segment: TranscriptionSegment = {\n          encounterId: session.encounterId,\n          timestamp: Date.now(),\n          text: alternative.transcript,\n          speaker,\n          confidence: alternative.confidence,\n          entities: this.extractMedicalEntities(alternative.transcript),\n          isPartial: false,\n        };\n\n        return segment;\n      } else {\n        console.warn(`[Deepgram] No valid alternatives found in response`);\n      }\n    } catch (error) {\n      console.error('[Deepgram] Transcription error:', error);\n      throw error;\n    }\n\n    return null;\n  }\n\n  mapSpeakerLabel(speakerId: number): string {\n    const speakerMap: Record<number, string> = {\n      0: 'Doctor',\n      1: 'Patient',\n    };\n    return speakerMap[speakerId] || 'Other';\n  }\n\n  identifySpeaker(words: any[], transcript: string, session: TranscriptionSession): string {\n    if (!words || words.length === 0) return 'Unknown';\n\n    const firstSpeakerId = words[0].speaker;\n\n    // Content-based speaker identification patterns\n    const doctorPatterns = [\n      /\\b(how are you feeling|what brings you in|let me examine|I'd like to|prescription|diagnosis|treatment|medication|mg|take this|follow up)\\b/i,\n      /\\b(blood pressure|heart rate|temperature|breathing|pulse|examination|symptoms|condition)\\b/i,\n      /\\b(I recommend|let's try|you should|take twice daily|come back in|schedule)\\b/i\n    ];\n\n    const patientPatterns = [\n      /\\b(I feel|I have|I've been|my|it hurts|pain in|since yesterday|for weeks|I can't)\\b/i,\n      /\\b(yes doctor|no doctor|thank you|okay|alright|I understand|when should I)\\b/i,\n      /\\b(it started|I noticed|I'm experiencing|I think|I believe|I'm worried)\\b/i\n    ];\n\n    // Check content patterns\n    const isDoctorContent = doctorPatterns.some(pattern => pattern.test(transcript));\n    const isPatientContent = patientPatterns.some(pattern => pattern.test(transcript));\n\n    if (isDoctorContent && !isPatientContent) {\n      return 'Doctor';\n    } else if (isPatientContent && !isDoctorContent) {\n      return 'Patient';\n    } else {\n      // Fall back to diarization mapping\n      return this.mapSpeakerLabel(firstSpeakerId);\n    }\n  }\n\n  extractMedicalEntities(text: string): any[] {\n    const entities: any[] = [];\n\n    // Medication patterns\n    const medicationRegex = /(\\b\\w+(?:azole|cillin|mycin|statin|pril|sartan|olol|azepam|epine|ine|one|ide)\\b)\\s*(?:(\\d+)\\s*(mg|mcg|g|ml|units?))?/gi;\n    let match;\n    while ((match = medicationRegex.exec(text)) !== null) {\n      entities.push({\n        type: 'medication',\n        text: match[0],\n        value: match[2],\n        unit: match[3],\n        attributes: {\n          name: match[1],\n          dose: match[2],\n          unit: match[3],\n        },\n      });\n    }\n\n    // Vital signs patterns\n    const vitalsRegex = /(?:blood pressure|bp|temperature|temp|pulse|heart rate|respiratory rate|oxygen|o2|spo2)\\s*(?:is|of|:)?\\s*(\\d+(?:\\/\\d+)?)\\s*(\\/|\\w+)?/gi;\n    while ((match = vitalsRegex.exec(text)) !== null) {\n      entities.push({\n        type: 'vital',\n        text: match[0],\n        value: match[1],\n        unit: match[2],\n      });\n    }\n\n    // Common symptoms\n    const symptomKeywords = ['pain', 'ache', 'fever', 'cough', 'fatigue', 'nausea', 'dizziness', 'shortness of breath'];\n    symptomKeywords.forEach(symptom => {\n      const regex = new RegExp(`\\\\b${symptom}\\\\b`, 'gi');\n      if (regex.test(text)) {\n        entities.push({\n          type: 'symptom',\n          text: symptom,\n        });\n      }\n    });\n\n    return entities;\n  }\n\n  async saveTranscriptionSegment(segment: TranscriptionSegment) {\n    const timestampStr = segment.timestamp.toString();\n    const item = {\n      pk: `ENCOUNTER#${segment.encounterId}`,\n      sk: `TRANSCRIPT#${timestampStr}`,\n      gsi1pk: `ENCOUNTER#${segment.encounterId}`,\n      gsi1sk: `TRANSCRIPT#${timestampStr}`,\n      ...segment,\n      timestamp: timestampStr, // Ensure timestamp is string for DynamoDB GSI\n      ttl: Math.floor(Date.now() / 1000) + (90 * 24 * 60 * 60), // 90 days\n    };\n\n    console.log(`[Transcription] Saving segment - text: \"${segment.text.substring(0, 50)}...\"`);\n    await docClient.send(\n      new PutCommand({\n        TableName: process.env.TABLE_NAME,\n        Item: item,\n      })\n    );\n  }\n\n  async stopTranscription(params: { sessionId: string }): Promise<{ transcriptCount: number; recordingId?: string }> {\n    console.log(`[Transcription] Stopping session ${params.sessionId}`);\n    \n    const session = await this.getSession(params.sessionId);\n    if (!session) {\n      throw new Error('Transcription session not found');\n    }\n\n    // Close live connection if exists\n    const connection = liveConnections.get(params.sessionId);\n    if (connection) {\n      try {\n        connection.finish();\n        liveConnections.delete(params.sessionId);\n        wsClients.delete(params.sessionId);\n        console.log(`[Transcription] Closed live connection for session ${params.sessionId}`);\n      } catch (error) {\n        console.error(`[Transcription] Error closing live connection:`, error);\n      }\n    }\n\n    // Process any remaining buffered audio\n    if (session.audioBuffer.length > 0) {\n      const combinedBuffer = Buffer.concat(session.audioBuffer);\n      try {\n        const segment = await this.transcribeWithDeepgram(session, combinedBuffer);\n        if (segment) {\n          await this.saveTranscriptionSegment(segment);\n        }\n      } catch (error) {\n        console.error('[Transcription] Failed to process final buffer:', error);\n      }\n    }\n\n    session.status = 'completed';\n    session.endTime = Date.now();\n\n    // Create recording metadata for this transcription session\n    let recordingId: string | undefined;\n    try {\n      console.log(`[Transcription] Creating recording metadata for session ${params.sessionId}, encounter ${session.encounterId}`);\n      recordingId = await this.createRecordingFromTranscription(session);\n      console.log(`[Transcription] Successfully created recording ${recordingId} for transcription session ${params.sessionId}`);\n    } catch (error) {\n      console.error(`[Transcription] CRITICAL: Failed to create recording for session ${params.sessionId}:`, error);\n    }\n\n    // Delete session\n    await this.deleteSession(params.sessionId);\n\n    // Count total transcript segments\n    const result = await docClient.send(\n      new QueryCommand({\n        TableName: process.env.TABLE_NAME,\n        KeyConditionExpression: 'pk = :pk AND begins_with(sk, :sk)',\n        ExpressionAttributeValues: {\n          ':pk': `ENCOUNTER#${session.encounterId}`,\n          ':sk': 'TRANSCRIPT#',\n        },\n        Select: 'COUNT',\n      })\n    );\n\n    return {\n      transcriptCount: result.Count || 0,\n      recordingId\n    };\n  }\n\n  async createRecordingFromTranscription(session: TranscriptionSession): Promise<string> {\n    console.log(`[createRecordingFromTranscription] Starting for session ${session.sessionId}, encounter ${session.encounterId}`);\n    \n    const recordingId = uuidv4();\n    const startTime = new Date(session.startTime).toISOString();\n    const endTime = new Date(session.endTime || Date.now()).toISOString();\n    const duration = (session.endTime || Date.now()) - session.startTime;\n\n    const recording = {\n      id: recordingId,\n      startTime,\n      endTime,\n      duration,\n      s3Key: `transcription-recordings/${session.encounterId}/${recordingId}.webm`,\n      transcriptionId: session.sessionId,\n      type: 'transcription-only',\n    };\n\n    console.log(`[createRecordingFromTranscription] Created recording object:`, recording);\n\n    // Get the current encounter\n    const currentEncounter = await docClient.send(\n      new GetCommand({\n        TableName: process.env.TABLE_NAME,\n        Key: {\n          pk: `ENCOUNTER#${session.encounterId}`,\n          sk: 'METADATA',\n        }\n      })\n    );\n\n    if (!currentEncounter.Item) {\n      console.error(`[createRecordingFromTranscription] Encounter ${session.encounterId} not found`);\n      throw new Error(`Encounter ${session.encounterId} not found`);\n    }\n\n    // Add recording to encounter\n    const existingRecordings = currentEncounter.Item.recordings || [];\n    const updatedRecordings = [...existingRecordings, recording];\n\n    console.log(`[createRecordingFromTranscription] Updating encounter with new recording`, {\n      existingCount: existingRecordings.length,\n      newCount: updatedRecordings.length\n    });\n\n    await docClient.send(\n      new UpdateCommand({\n        TableName: process.env.TABLE_NAME,\n        Key: {\n          pk: `ENCOUNTER#${session.encounterId}`,\n          sk: 'METADATA',\n        },\n        UpdateExpression: 'SET recordings = :recordings',\n        ExpressionAttributeValues: {\n          ':recordings': updatedRecordings,\n        },\n      })\n    );\n\n    console.log(`[createRecordingFromTranscription] Successfully updated encounter ${session.encounterId} with recording ${recordingId}`);\n    return recordingId;\n  }\n\n  async getTranscriptionSegments(encounterId: string, limit = 100): Promise<TranscriptionSegment[]> {\n    const result = await docClient.send(\n      new QueryCommand({\n        TableName: process.env.TABLE_NAME,\n        KeyConditionExpression: 'pk = :pk AND begins_with(sk, :sk)',\n        ExpressionAttributeValues: {\n          ':pk': `ENCOUNTER#${encounterId}`,\n          ':sk': 'TRANSCRIPT#',\n        },\n        Limit: limit,\n        ScanIndexForward: true, // Chronological order\n      })\n    );\n\n    return (result.Items || []) as TranscriptionSegment[];\n  }\n\n  async handleTranscriptEvent(session: TranscriptionSession, data: any, isPartial: boolean) {\n    try {\n      if (!data.channel || !data.channel.alternatives || data.channel.alternatives.length === 0) {\n        return;\n      }\n\n      const alternative = data.channel.alternatives[0];\n      if (!alternative.transcript || alternative.transcript.trim().length === 0) {\n        return;\n      }\n\n      // Extract speaker information\n      let speaker = 'Unknown';\n      if (data.channel.alternatives[0].words && data.channel.alternatives[0].words.length > 0) {\n        const speakerId = data.channel.alternatives[0].words[0].speaker;\n        speaker = this.mapSpeakerLabel(speakerId);\n      }\n\n      const segment: TranscriptionSegment = {\n        encounterId: session.encounterId,\n        timestamp: Date.now(),\n        text: alternative.transcript,\n        speaker,\n        confidence: alternative.confidence,\n        entities: this.extractMedicalEntities(alternative.transcript),\n        isPartial,\n      };\n\n      // Save the segment if it's final\n      if (!isPartial) {\n        await this.saveTranscriptionSegment(segment);\n      }\n\n      // Send to WebSocket client\n      const wsClient = wsClients.get(session.sessionId);\n      if (wsClient && wsClient.apiGatewayClient) {\n        try {\n          const { PostToConnectionCommand } = await import('@aws-sdk/client-apigatewaymanagementapi');\n          await wsClient.apiGatewayClient.send(\n            new PostToConnectionCommand({\n              ConnectionId: wsClient.connectionId,\n              Data: JSON.stringify({\n                type: 'transcript',\n                segment,\n                sessionId: session.sessionId,\n                isPartial,\n              }),\n            })\n          );\n        } catch (wsError) {\n          console.error(`[Transcription] Error sending transcript to WebSocket:`, wsError);\n        }\n      }\n      \n      console.log(`[Transcription] ${isPartial ? 'Partial' : 'Final'} transcript:`, segment.text);\n      \n    } catch (error) {\n      console.error(`[Transcription] Error handling transcript event:`, error);\n    }\n  }\n}\n\nexport const transcriptionService = new TranscriptionService();"]}